package mercury;
import java_cup.runtime.*;
import mercury.arm.assembler.TokenTypes;
import mercury.arm.assembler.Token;
import mercury.arm.assembler.TokenList;
import java.io.FileReader;


    action code{::}
    /* Codigo del parser, se copia integramente a la clase final.
        Se agrega el manejo de errores. */
    parser code {:
        @Override
        public void syntax_error(Symbol sy){
                report_error("Error de sintaxis. Linea: " + (sy.left + 1) +
                " Columna: " + sy.right + ". Texto: " + sy.value + " ", null);
      }

        /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
            StringBuilder m = new StringBuilder("Error");
            if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
                if (s.left >= 0) {
                    m.append(" in line "+(s.left+1));
                    if (s.right >= 0)
                        m.append(", column "+(s.right+1));
                }
            }
            m.append(" : "+message);
            System.err.println(m);
        }
        public void unrecovered_syntax_error(Symbol cur_token){
          System.out.println("Error, no se puede continuar con la ejecucion.");
        }

          public void report_fatal_error(String message, Object info) {
            report_error(message, info);
            System.exit(1);
        }

        /*
        This method assures the execution of both analysis, lexical and syntactic. Besides, symbols generated in the first
        stage are taken into account in the next analysis.
        */
        public static void main(String[] args){
            try {
                SyntaxAnalysis synAnalysis = new SyntaxAnalysis(
                        new LexicalAnalysis( new FileReader(args[0])));
                Object result = synAnalysis.parse().value;
                System.out.println("\n*** Syntactic analysis final results ***");
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

:}
     /* ------------Declaracion de simbolos terminales y no terminales---------- */

     /* Terminales (tokens obtenidos por el analizador lexico).

        Terminales que no tienen un valor son listados primero, los terminales que
        tienen un valor como los enteros son listados en la segunda o demas lineas. */
     terminal        newline, comma, leftpar, rightpar, sharp;
     terminal String setlabel, comment, register, branch, calllabel, mnemonic, conditionalmnemonic, mnemonicset, mnemonicsetconditional, compare, compareconditional, move, conditionalmove, moveset, movesetconditional, mla, mlaconditional, mlaset, mlasetconditional, memorymnemonic, memorymnemonicconditional, hex, num;

     /* No terminales usados en la seccion gramatical

        Primero se lista los no terminales que tienen un valor Object y despues
        se lista los no terminales que tienen un entero. Un Object se refiere a que
        no tienen tipo, pudiendo ser entero o String. */

     non terminal Object     PROGRAM, STATEMENT, INSTRUCTION, DATAPROCESSING, MEMORY, DPADDR, RELATIVEADDR, CMVADDR, MLAADDR;
     non terminal String     NORMALADDR, DPMNEMONIC, CMPMNEMONIC, MVMNEMONIC, MLAMNEMONIC, MEMMNEMONIC, IMMEDIATE;

     /* ------------------- Seccion de la gramatica ------------------------ */
/**
     /* La gramatica de nuestro analizador.

     PROGRAM -> setlabel comment | comment | INSTRUCTION comment | INSTRUCTION newline
     INSTRUCTION -> DATAPROCESSING | MEMORY | BRANCH
     DATAPROCESSING -> DPMNEMONIC DPADDR | CMPMNEMONIC CMVADDR | MVMNEMONIC CMVADDR |
                       MLAMNEMONIC MLAADDR
     MEMORY -> MEMMNEMONIC register comma RELATIVEADDR
     BRANCH -> branch calllabel
     DPADDR-> NORMALADDR comma register | NORMALADDR comma IMMEDIATE |
                    NORMALADDR comma RELATIVEADDR
     NORMALADDR -> register comma register
     RELATIVEADDR-> leftpar register comma IMMEDIATE rightpar | leftpar register rightpar |
                    leftpar NORMALADDR rightpar
     CMVADDR -> NORMALADDR | register comma IMMEDIATE
     MLAADDR -> NORMALADDR comma NORMALADDR | NORMALADDR comma register comma IMMEDIATE
     DPMNEMONIC -> mnemonic | conditionalmnemonic | mnemonicset | mnemonicsetconditional
     CMPMNEMONIC -> compare | compareconditional
     MVMNEMONIC -> move | condidionalmove | moveset | movesetconditional
     MLAMNEMONIC -> mla | mlaconditional | mlaset | mlasetconditional
     MEMMNEMONIC -> memorymnemonic | memorymnemonicconditional
     IMMEDIATE -> sharp hex | sharp num
  */

         /*
           PROGRAM ::=  PROGRAM setlabel INSTRUCTION comment INSTRUCTION | setlabel INSTRUCTION comment INSTRUCTION|
           INSTRUCTION comment INSTRUCTION| INSTRUCTION newline | INSTRUCTION comment | error newline INSTRUCTION;
           INSTRUCTION ::=  DATAPROCESSING | MEMORY | BRANCH;
           DATAPROCESSING ::= DPMNEMONIC DPADDR | CMPMNEMONIC CMVADDR | MVMNEMONIC CMVADDR |
                                  MLAMNEMONIC MLAADDR;
           MEMORY ::= MEMMNEMONIC register comma RELATIVEADDR;
                BRANCH ::= branch calllabel;
                DPADDR ::= NORMALADDR comma register | NORMALADDR comma IMMEDIATE |
                               NORMALADDR comma RELATIVEADDR;
                NORMALADDR ::= register comma register;
                RELATIVEADDR ::= leftpar register comma IMMEDIATE rightpar | leftpar register rightpar |
                               leftpar NORMALADDR rightpar;
                CMVADDR ::= NORMALADDR | register comma IMMEDIATE;
                MLAADDR ::= NORMALADDR comma NORMALADDR | NORMALADDR comma register comma IMMEDIATE;
                DPMNEMONIC ::= mnemonic | conditionalmnemonic | mnemonicset | mnemonicsetconditional;
                CMPMNEMONIC ::= compare | compareconditional;
                MVMNEMONIC ::= move | conditionalmove | moveset | movesetconditional;
                MLAMNEMONIC ::= mla | mlaconditional | mlaset | mlasetconditional;
                MEMMNEMONIC ::= memorymnemonic | memorymnemonicconditional;
                IMMEDIATE ::= sharp hex | sharp num;
         */

  start with PROGRAM;


  PROGRAM ::= PROGRAM STATEMENT| STATEMENT;
  STATEMENT::=   setlabel comment | setlabel newline| INSTRUCTION newline | INSTRUCTION comment | newline |
                 error newline STATEMENT;
  INSTRUCTION ::=  DATAPROCESSING | MEMORY | branch calllabel;
  DATAPROCESSING ::= DPMNEMONIC DPADDR | CMPMNEMONIC CMVADDR | MVMNEMONIC CMVADDR |
                         MLAMNEMONIC MLAADDR;
  MEMORY ::= MEMMNEMONIC register comma RELATIVEADDR;
  DPADDR ::= NORMALADDR comma register | NORMALADDR comma IMMEDIATE |
             NORMALADDR comma RELATIVEADDR;
  NORMALADDR ::= register comma register;
  RELATIVEADDR ::= leftpar register comma IMMEDIATE rightpar | leftpar register rightpar |
                   leftpar NORMALADDR rightpar;
  CMVADDR ::= NORMALADDR | register comma IMMEDIATE;
  MLAADDR ::= NORMALADDR comma NORMALADDR | NORMALADDR comma register comma IMMEDIATE;
  DPMNEMONIC ::= mnemonic | conditionalmnemonic | mnemonicset | mnemonicsetconditional;
  CMPMNEMONIC ::= compare | compareconditional;
  MVMNEMONIC ::= move | conditionalmove | moveset | movesetconditional;
  MLAMNEMONIC ::= mla | mlaconditional | mlaset | mlasetconditional;
  MEMMNEMONIC ::= memorymnemonic | memorymnemonicconditional;
  IMMEDIATE ::= sharp hex | sharp num;

